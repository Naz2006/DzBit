#include <stdio.h>
#include <stdlib.h>
#include <time.h>

// 112 Кузнецов Назар
// Функция сравнивает к-во единичных бит в числах
// Возвращает 1, если бит в 1-м числе меньше, -1 - больше, 0 - одинаково
int bit_compare(const int* k1, const int* k2) {
	unsigned b1, b2;					// Биты
	int n1 = 0, n2 = 0;					// Количества ед. бит в числах

	for (int i = 31; i >= 0; i--) {
		b1 = (1 << i);
		b1 &= (*k1);
		b1 >>= i;
		b2 = (1 << i);
		b2 &= (*k2);
		b2 >>= i;
		if (b1 == 1) n1++;
		if (b2 == 1) n2++;
	}
	if (n1 < n2) return 1;
	if (n1 > n2) return -1;
	return 0;
}

// 112 Кузнецов Назар
// Функция проверяет массив на отсортированность
// На вход подается массив и его длина
int sort_check(int a[], int n) {
	for (int i = 0; i < n - 1; i++) {
		if (bit_compare(a + i, a + i + 1) == 1) return 1;
	}
	return 0;
}

// 112 Кузнецов Назар
// Функция выводит число в двоичном представлении
void bit_print(unsigned K) {
	unsigned b;					// Бит числа
	int N = 0;					// Количество единичных бит
	printf("%d: ", (int)K);				// Печатаем чисало
	for (int i = 31; i >= 0; i--) {			// Печатаем число побитово
		b = 1 << i;				// Переносим i на позицию бита
		b &= K;					// Определяем i-ый бит числа
		b >>= i;				// Переносим определенный бит обратно
		if (b == 1) N++;			// Считаем количество единичных бит
		printf("%u", b);
		if (i % 8 == 0) printf(" ");
	}
	printf("%d\n", N);				// Выводим к-во единичных бит
}

// 112 Кузнецов Назар
// Функция копирует массив из файла в данный массив
// На вход подается имя файла, массив и его длина
int read_file(char filename[], int a[], int n) {
	FILE* file;
	if ((file = fopen(filename, "r")) == 0) return 1;
	for (int i = 0; i < n; i++) {
		fscanf(file, "%d", &a[i]);
	}
	fclose(file);
	return 0;
}

// 112 Кузнецов Назар
// Функция генерирует массив заданной длины
// И кладет его в файл filename
// На вход подается имя файла и массив
int gener_mas(char filename[], int n) {
	FILE* file;
	if ((file = fopen(filename, "w")) == 0) return 1;
	srand(time(NULL));					//  Иницилизируем переменную функции rand
	for (int i = 0; i < n; i++) {
		fprintf(file, "%d ", rand() * rand() * rand());
		if ((i + 1) % 10 == 0) fprintf(file, "%c", '\n');
	}
	fclose(file);
	return 0;
}

// 112 Кузнецов Назар
// Функция меняет местами элементы массива
// На вход подаются два числа
void swap(int* a, int* b) {
	int t = *a;
	*a = *b;
	*b = t;
}

// 112 Кузнецов Назар
// Функция сортирует часть массива (который лежит между l и r)
// На вход подается массив, и его границы l и r, возвращает индекс последнего элемента
int partition(int arr[], int l, int h) {
	int x = arr[h];
	int i = (l - 1);

	for (int j = l; j <= h - 1; j++) {
		if (bit_compare(&arr[j], &x) == -1) {
			i++;
			swap(&arr[i], &arr[j]);
		}
	}
	swap(&arr[i + 1], &arr[h]);
	return (i + 1);
}

// 112 Кузнецов Назар
// Функция сортирует часть массива
// На вход подается массив, и его границы, по которым будет проходить сортировка
void qsort_no_rec(int arr[], int l, int h) {
	int stack[40];          	// Создаем мини-стек
	int top = -1;           	// Вершина мини-стека
	stack[++top] = l;       	// Кладем в стек левую границу
	stack[++top] = h;       	// Кладем в стек правую границу

	while (top >= 0) {      	// Сортируем, пока стек не пуст
		h = stack[top--];
		l = stack[top--];

		int p = partition(arr, l, h);

		if (p - 1 > l) {
			stack[++top] = l;
			stack[++top] = p - 1;
		}

		if (p + 1 < h) {
			stack[++top] = p + 1;
			stack[++top] = h;
		}
	}
}